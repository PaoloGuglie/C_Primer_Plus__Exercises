The character string is one of the most useful and important data types in C.

A CHARACTER STRING is a char array terminated with a null character (\0).

The puts() function, like printf(), belongs to the stdio.h family of input/output functions, it only displays strings, and, unlike printf(), it automatically appends a newline to the string it displays.

There are many ways to define a string. The principal ways are using string constants, using char arrays and using char pointers.

A STRING LITERAL, also called a STRING CONSTANT, is anything enclosed in double quotation marks.

Character string constants are placed in the STATIC STORAGE CLASS. This means that if I use a string constant in a function, the string is stored just once and lasts for the duration fo the program, even if the function is called several times. The entire quoted phrase acts as a pointer to where the string is stored.

Character array != string

Initializing character arrays is one case when it really does make sense to let the compiler determine the array size. That's because string-processing functions typically don't need to know the size of the array because they can simply look for the null character to mark the end.
This works only if I initialize the array. If I create an array I intend to fill later, I need to specify the size when I declare it.

When I do this:
    const char ar[] = "Something is happening";
The quoted string is stored in a data segment that is part of the executable file; When the program is loaded into memory, so is that segment that is part of the executable file. The quoted string is said to be in STATIC MEMORY.
But the memory for the array is allocated only after the program begins runnig. At that time, the qouted string is copied into the array. At this time, there are two copies of the string.
Then, the compiler will recognize the name "ar" as a synonym for the address of the first array element. In the array form, "ar" is an ADDRESS CONSTANT: I can't change it, because that would mean changing the address where the array is stored.

When I do this:
    const char *pt = "Something is happening";
Also causes 29 elements in static storage to be set aside for the string. In addition, once the program begins execution, it sets aside one more storage location for the POINTER VARIABLE pt and stores the address of the string in the pointer variable. This variable initially points to the first character of the string, but the value can be changed. I can use the increment operator.
A string literal is considered const data; because pt points to const data, it should be declared as pointing to const data. I can change the value of pt, but I cannot use pt to change the data itself. If I copy a string literal to an array, on the other hand, I am free to change the data unless I choose to declare the array as const.

Initializing an array copies a string from static storage to the array (I can change the array, not the pointer), whereas initializing the pointer merely copies the address of the string (I can change the pointer, not the array).

The part of memory used for static data is different from that used for dynamic memory. Some compilers even use a different number of bits to represent the two kinds of memory.

        char heart[] = "Hello!";
        const char *head = "Bye!";
The array name "heart" is a constant, but the pointer "head" is a variable. Only the pointer can use the incremente operator.

The elements of an array are variables (unless the array was declared as const), but the name is not a variable.

Don't use a pointer to a string literal if I plan to alter the string:
        char *pt = "Klingon";
        pt[0] = 'F';
The behavior for such an action is undefined. A compiler can choose to represent all identical string literals with a single copy in memory. So I could be changing every instance of the word "Klingon" (every instance of the word has the same address):
        "Klingon: beware the Klingons"  ==>  "Flingon: beward the Flingons"
The recommended practice for initializing a pointer to a string literal is to use the const modifier:
        const char *pt = "Klingon";

        const char *arr[5] = {}
The "arr" array is an array of 5 pointers, taking up, for example, 40 bytes. The pointers point to the locations of the string literals used for initialization, stored in static memory.

        char arr[5][40] = {}
The "arr" array is an array of 5 arrays, each of 40 char values, occupying 200 bytes. The arrays containcopies of the string literals, so each string is stored twice. Furthermore, the allocation of memory in the arrays is inefficient, for ecah element has to be the same size, large enough for the longest string.

An array of pointers is more efficient than an array of character arrays, to represent strings.
Don't use pointers to string literals if I want to alter strings or set aside space for string input.

The gets() function reads an entire line up through the newline character, discards the newline character, stores the remaining characters, adding a null character to create a C string. It's often paired with puts(), which displays a string, adding a newline.
PROBLEM: gets() doesn't check to see if the input line actually fits into the array. If the input string is too long, I get BUFFER OVERFLOW, meaning the excess characters overflow the designated target. The extra characters might just go into unused memory and cause no immediate problems, or they may overwrite other data in my program, ...
gets() has been dropped from the standard (even though many compilers still include it) because its unsafe behavior poses a security risk: in the past, people have taken advantage of system programming that uses gets() to insert and run code that compromised system security.

On unix systems, SEGMENTATION FAULT indicates the program attempted to access memory not allocated to it.

The traditional alternative are fgets(), and gets_s().

The fgets() function meets the posible overflow problem by taking a second argument that limits the number of characters to be read. This function is designed for file input.
If the second argument has value x, fgets() reads up to x-1 characters or throught the newline character, whichever comes first.
If fgets() reads the newline, it stores it in the string, unlike gets(), which discards it.
It takes a third argument indicating which file to read. To read from the keyboard, use "stdin" as the argument; this identifier is defined in "stdio.h" .

Because the fgets() function includes the newline as part of the string, it's often paired with fputs(), which work like puts(), except that it doesn't automatically append a newline. It takes a second argument to indicate which file to write to. For the monitor, use "stdout" .

The fgets() function returns a pointer to char. If all goes well, it just returns the same address that was passed to it as the first argument. If the function encounters end-of-file (or some sort of read error) it returns a special pointer called the NULL POINTER. It's a pointer guaranteed not to point to valued data so it can be used to indicate a special case. It can be represented by the digit 0 or, more commonly in C, by the macro NULL.