The character string is one of the most useful and important data types in C.

A CHARACTER STRING is a char array terminated with a null character (\0).

The puts() function, like printf(), belongs to the stdio.h family of input/output functions, it only displays strings, and, unlike printf(), it automatically appends a newline to the string it displays.

There are many ways to define a string. The principal ways are using string constants, using char arrays and using char pointers.

A STRING LITERAL, also called a STRING CONSTANT, is anything enclosed in double quotation marks.

Character string constants are placed in the STATIC STORAGE CLASS. This means that if I use a string constant in a function, the string is stored just once and lasts for the duration fo the program, even if the function is called several times. The entire quoted phrase acts as a pointer to where the string is stored.

Character array != string

Initializing character arrays is one case when it really does make sense to let the compiler determine the array size. That's because string-processing functions typically don't need to know the size of the array because they can simply look for the null character to mark the end.
This works only if I initialize the array. If I create an array I intend to fill later, I need to specify the size when I declare it.

When I do this:
    const char ar[] = "Something is happening";
The quoted string is stored in a data segment that is part of the executable file; When the program is loaded into memory, so is that segment that is part of the executable file. The quoted string is said to be in STATIC MEMORY.
But the memory for the array is allocated only after the program begins runnig. At that time, the qouted string is copied into the array. At this time, there are two copies of the string.
Then, the compiler will recognize the name "ar" as a synonym for the address of the first array element. In the array form, "ar" is an ADDRESS CONSTANT: I can't change it, because that would mean changing the address where the array is stored.

When I do this:
    const char *pt = "Something is happening";
Also causes 29 elements in static storage to be set aside for the string. In addition, once the program begins execution, it sets aside one more storage location for the POINTER VARIABLE pt and stores the address of the string in the pointer variable. This variable initially points to the first character of the string, but the value can be changed. I can use the increment operator.
A string literal is considered const data; because pt points to const data, it should be declared as pointing to const data. I can change the value of pt, but I cannot use pt to change the data itself. If I copy a string literal to an array, on the other hand, I am free to change the data unless I choose to declare the array as const.

Initializing an array copies a string from static storage to the array (I can change the array, not the pointer), whereas initializing the pointer merely copies the address of the string (I can change the pointer, not the array).

The part of memory used for static data is different from that used for dynamic memory. Some compilers even use a different number of bits to represent the two kinds of memory.

        char heart[] = "Hello!";
        const char *head = "Bye!";
The array name "heart" is a constant, but the pointer "head" is a variable. Only the pointer can use the incremente operator.

The elements of an array are variables (unless the array was declared as const), but the name is not a variable.

Don't use a pointer to a string literal if I plan to alter the string:
        char *pt = "Klingon";
        pt[0] = 'F';
The behavior for such an action is undefined. A compiler can choose to represent all identical string literals with a single copy in memory. So I could be changing every instance of the word "Klingon" (every instance of the word has the same address):
        "Klingon: beware the Klingons"  ==>  "Flingon: beward the Flingons"
The recommended practice for initializing a pointer to a string literal is to use the const modifier:
        const char *pt = "Klingon";

        const char *arr[5] = {}
The "arr" array is an array of 5 pointers, taking up, for example, 40 bytes. The pointers point to the locations of the string literals used for initialization, stored in static memory.

        char arr[5][40] = {}
The "arr" array is an array of 5 arrays, each of 40 char values, occupying 200 bytes. The arrays containcopies of the string literals, so each string is stored twice. Furthermore, the allocation of memory in the arrays is inefficient, for ecah element has to be the same size, large enough for the longest string.

An array of pointers is more efficient than an array of character arrays, to represent strings.
Don't use pointers to string literals if I want to alter strings or set aside space for string input.

The gets() function reads an entire line up through the newline character, discards the newline character, stores the remaining characters, adding a null character to create a C string. It's often paired with puts(), which displays a string, adding a newline.
PROBLEM: gets() doesn't check to see if the input line actually fits into the array. If the input string is too long, I get BUFFER OVERFLOW, meaning the excess characters overflow the designated target. The extra characters might just go into unused memory and cause no immediate problems, or they may overwrite other data in my program, ...
gets() has been dropped from the standard (even though many compilers still include it) because its unsafe behavior poses a security risk: in the past, people have taken advantage of system programming that uses gets() to insert and run code that compromised system security.

On unix systems, SEGMENTATION FAULT indicates the program attempted to access memory not allocated to it.

The traditional alternative are fgets(), and gets_s().

The fgets() function meets the posible overflow problem by taking a second argument that limits the number of characters to be read. This function is designed for file input.
If the second argument has value x, fgets() reads up to x-1 characters or throught the newline character, whichever comes first.
If fgets() reads the newline, it stores it in the string, unlike gets(), which discards it.
It takes a third argument indicating which file to read. To read from the keyboard, use "stdin" as the argument; this identifier is defined in "stdio.h" .

Because the fgets() function includes the newline as part of the string, it's often paired with fputs(), which work like puts(), except that it doesn't automatically append a newline. It takes a second argument to indicate which file to write to. For the monitor, use "stdout" .

The fgets() function returns a pointer to char. If all goes well, it just returns the same address that was passed to it as the first argument. If the function encounters end-of-file (or some sort of read error) it returns a special pointer called the NULL POINTER. It's a pointer guaranteed not to point to valued data so it can be used to indicate a special case. It can be represented by the digit 0 or, more commonly in C, by the macro NULL.

BUFFERED I/O means the input is stored in temporary memory (the buffer) until the Return key is pressed; this adds a newline character to the input and sends the whole line on to fgets().
If the input line exceeds the buffer size (allowed string space), the remaining characters remain in the input stream.
On output, fputs() sends characters to another buffer, and when a newline is sent, the buffer contents are sent on to the display.

THe fact that fgets() stores the newline present a problem if I don't want to store it (I can loop the string and, if I encounter a newline, change it), or an opportunity to verify whether the whole line was read.

Clean input:
                int i = 0;

                // Read a whole line and replace the newline character with a null character, or read
                // the part of a line that fits and discard the rest:
                // ("words" is a char array to store a line; pg. 459 book)

                while (words[i] != '\n' && words[i] != '\0')
                {
                        i++;
                }

                if (words[i] == '\n')
                {
                        // Delete newline character
                        words[i] == '\0';
                }

                else  // reached null character
                {
                        // Read and discard the rest of the input line
                        while (getchar() != '\n')
                        {
                                continue
                        }
                }

Null character and null pointer are conceptually different:
        - The null character, or '\0', is the character to mark the end of a C string. Its character code is zero. That isn't the code of any character, so it won't show up accidentally in some other part of the string.
        - The null pointer, or NULL, has a value that doesn't correspond to a valid address of data. It's often used by functions that otherwise return valid addresses to indicate some special occurrence, such as EOF or failure to perform as expected.
The null character is an integer type, while the null pointer is a pointer type. Both can be represented numerically by the value 0. But, conceptually, they are different types of 0.
The null character, being a character, is one byte. The null pointer, being an address, typically is four bytes.

gets_s(words, STLEN) :
        - Just reads from the standard input.
        - If it reads a newline, it discards it.
        - If it reads the maximum number of characters and fails to read a newline, it takes several steps:
                + it sets the first character of the destination array to the null character.
                + it reads and discards subsequent input until a newline or end-of-file is encountered.
                + it returns the null pointer.
                + it invokes an implementation-dependent "handler" function which may cause the program to exit or abort.

As long as the input line isn't too long, gets_s() behaves like gets().
gets_s() disposes of the rest of the input line whether I want to or not. Less flexible than fgets().

Given that gets_s() is optional, using fgets() is the better choice.

If the remainder of a line is left in place, it becomes the input for the next read statement. This can cause the program to crash if the next read statement is looking for a type double value.

If I specify a field width, scanf() collects up to n characters or up to the first whitespace character, whichever comes first.

The scanf() function returns an integer value that equals the number of items successfully read or returns EOF if it encounters the end of file.

The typical use for scanf() is reading and converting a mixture of data types in some standard form. Or to precess input a word at a time.

The scanf() function has the same potential defect as gets(): it can create an overflow if the input word doesn't fit the destination. But I can use the field-width option in the %s specifier to prevent overflow.